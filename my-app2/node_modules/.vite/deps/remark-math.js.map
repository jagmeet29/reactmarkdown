{
  "version": 3,
  "sources": ["../../mdast-util-math/lib/index.js", "../../micromark-extension-math/dev/lib/math-flow.js", "../../micromark-extension-math/dev/lib/math-text.js", "../../micromark-extension-math/dev/lib/syntax.js", "../../micromark-extension-math/dev/lib/html.js", "../../remark-math/lib/index.js"],
  "sourcesContent": ["/**\r\n * @typedef {import('hast').Element} HastElement\r\n * @typedef {import('hast').ElementContent} HastElementContent\r\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\r\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\r\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\r\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\r\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\r\n * @typedef {import('../index.js').InlineMath} InlineMath\r\n * @typedef {import('../index.js').Math} Math\r\n *\r\n * @typedef ToOptions\r\n *   Configuration.\r\n * @property {boolean | null | undefined} [singleDollarTextMath=true]\r\n *   Whether to support math (text) with a single dollar (default: `true`).\r\n *\r\n *   Single dollars work in Pandoc and many other places, but often interfere\r\n *   with “normal” dollars in text.\r\n *   If you turn this off, you can still use two or more dollars for text math.\r\n */\r\n\r\nimport {ok as assert} from 'devlop'\r\nimport {longestStreak} from 'longest-streak'\r\n\r\n/**\r\n * Create an extension for `mdast-util-from-markdown`.\r\n *\r\n * @returns {FromMarkdownExtension}\r\n *   Extension for `mdast-util-from-markdown`.\r\n */\r\nexport function mathFromMarkdown() {\r\n  return {\r\n    enter: {\r\n      mathFlow: enterMathFlow,\r\n      mathFlowFenceMeta: enterMathFlowMeta,\r\n      mathText: enterMathText\r\n    },\r\n    exit: {\r\n      mathFlow: exitMathFlow,\r\n      mathFlowFence: exitMathFlowFence,\r\n      mathFlowFenceMeta: exitMathFlowMeta,\r\n      mathFlowValue: exitMathData,\r\n      mathText: exitMathText,\r\n      mathTextData: exitMathData\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {FromMarkdownHandle}\r\n   */\r\n  function enterMathFlow(token) {\r\n    /** @type {HastElement} */\r\n    const code = {\r\n      type: 'element',\r\n      tagName: 'code',\r\n      properties: {className: ['language-math', 'math-display']},\r\n      children: []\r\n    }\r\n    this.enter(\r\n      {\r\n        type: 'math',\r\n        meta: null,\r\n        value: '',\r\n        data: {hName: 'pre', hChildren: [code]}\r\n      },\r\n      token\r\n    )\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {FromMarkdownHandle}\r\n   */\r\n  function enterMathFlowMeta() {\r\n    this.buffer()\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {FromMarkdownHandle}\r\n   */\r\n  function exitMathFlowMeta() {\r\n    const data = this.resume()\r\n    const node = this.stack[this.stack.length - 1]\r\n    assert(node.type === 'math')\r\n    node.meta = data\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {FromMarkdownHandle}\r\n   */\r\n  function exitMathFlowFence() {\r\n    // Exit if this is the closing fence.\r\n    if (this.data.mathFlowInside) return\r\n    this.buffer()\r\n    this.data.mathFlowInside = true\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {FromMarkdownHandle}\r\n   */\r\n  function exitMathFlow(token) {\r\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\r\n    const node = this.stack[this.stack.length - 1]\r\n    assert(node.type === 'math')\r\n    this.exit(token)\r\n    node.value = data\r\n    // @ts-expect-error: we defined it in `enterMathFlow`.\r\n    const code = /** @type {HastElement} */ (node.data.hChildren[0])\r\n    assert(code.type === 'element')\r\n    assert(code.tagName === 'code')\r\n    code.children.push({type: 'text', value: data})\r\n    this.data.mathFlowInside = undefined\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {FromMarkdownHandle}\r\n   */\r\n  function enterMathText(token) {\r\n    this.enter(\r\n      {\r\n        type: 'inlineMath',\r\n        value: '',\r\n        data: {\r\n          hName: 'code',\r\n          hProperties: {className: ['language-math', 'math-inline']},\r\n          hChildren: []\r\n        }\r\n      },\r\n      token\r\n    )\r\n    this.buffer()\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {FromMarkdownHandle}\r\n   */\r\n  function exitMathText(token) {\r\n    const data = this.resume()\r\n    const node = this.stack[this.stack.length - 1]\r\n    assert(node.type === 'inlineMath')\r\n    this.exit(token)\r\n    node.value = data\r\n    const children = /** @type {Array<HastElementContent>} */ (\r\n      // @ts-expect-error: we defined it in `enterMathFlow`.\r\n      node.data.hChildren\r\n    )\r\n    children.push({type: 'text', value: data})\r\n  }\r\n\r\n  /**\r\n   * @this {CompileContext}\r\n   * @type {FromMarkdownHandle}\r\n   */\r\n  function exitMathData(token) {\r\n    this.config.enter.data.call(this, token)\r\n    this.config.exit.data.call(this, token)\r\n  }\r\n}\r\n\r\n/**\r\n * Create an extension for `mdast-util-to-markdown`.\r\n *\r\n * @param {ToOptions | null | undefined} [options]\r\n *   Configuration (optional).\r\n * @returns {ToMarkdownExtension}\r\n *   Extension for `mdast-util-to-markdown`.\r\n */\r\nexport function mathToMarkdown(options) {\r\n  let single = (options || {}).singleDollarTextMath\r\n\r\n  if (single === null || single === undefined) {\r\n    single = true\r\n  }\r\n\r\n  inlineMath.peek = inlineMathPeek\r\n\r\n  return {\r\n    unsafe: [\r\n      {character: '\\r', inConstruct: 'mathFlowMeta'},\r\n      {character: '\\n', inConstruct: 'mathFlowMeta'},\r\n      {\r\n        character: '$',\r\n        after: single ? undefined : '\\\\$',\r\n        inConstruct: 'phrasing'\r\n      },\r\n      {character: '$', inConstruct: 'mathFlowMeta'},\r\n      {atBreak: true, character: '$', after: '\\\\$'}\r\n    ],\r\n    handlers: {math, inlineMath}\r\n  }\r\n\r\n  /**\r\n   * @type {ToMarkdownHandle}\r\n   * @param {Math} node\r\n   */\r\n  // Note: fixing this code? Please also fix the similar code for code:\r\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/code.js>\r\n  function math(node, _, state, info) {\r\n    const raw = node.value || ''\r\n    const tracker = state.createTracker(info)\r\n    const sequence = '$'.repeat(Math.max(longestStreak(raw, '$') + 1, 2))\r\n    const exit = state.enter('mathFlow')\r\n    let value = tracker.move(sequence)\r\n\r\n    if (node.meta) {\r\n      const subexit = state.enter('mathFlowMeta')\r\n      value += tracker.move(\r\n        state.safe(node.meta, {\r\n          after: '\\n',\r\n          before: value,\r\n          encode: ['$'],\r\n          ...tracker.current()\r\n        })\r\n      )\r\n      subexit()\r\n    }\r\n\r\n    value += tracker.move('\\n')\r\n\r\n    if (raw) {\r\n      value += tracker.move(raw + '\\n')\r\n    }\r\n\r\n    value += tracker.move(sequence)\r\n    exit()\r\n    return value\r\n  }\r\n\r\n  /**\r\n   * @type {ToMarkdownHandle}\r\n   * @param {InlineMath} node\r\n   */\r\n  // Note: fixing this code? Please also fix the similar code for inline code:\r\n  // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/main/lib/handle/inline-code.js>\r\n  function inlineMath(node, _, state) {\r\n    let value = node.value || ''\r\n    let size = 1\r\n\r\n    if (!single) size++\r\n\r\n    // If there is a single dollar sign on its own in the math, use a fence of\r\n    // two.\r\n    // If there are two in a row, use one.\r\n    while (\r\n      new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)\r\n    ) {\r\n      size++\r\n    }\r\n\r\n    const sequence = '$'.repeat(size)\r\n\r\n    // If this is not just spaces or eols (tabs don’t count), and either the\r\n    // first and last character are a space or eol, or the first or last\r\n    // character are dollar signs, then pad with spaces.\r\n    if (\r\n      // Contains non-space.\r\n      /[^ \\r\\n]/.test(value) &&\r\n      // Starts with space and ends with space.\r\n      ((/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value)) ||\r\n        // Starts or ends with dollar.\r\n        /^\\$|\\$$/.test(value))\r\n    ) {\r\n      value = ' ' + value + ' '\r\n    }\r\n\r\n    let index = -1\r\n\r\n    // We have a potential problem: certain characters after eols could result in\r\n    // blocks being seen.\r\n    // For example, if someone injected the string `'\\n# b'`, then that would\r\n    // result in an ATX heading.\r\n    // We can’t escape characters in `inlineMath`, but because eols are\r\n    // transformed to spaces when going from markdown to HTML anyway, we can swap\r\n    // them out.\r\n    while (++index < state.unsafe.length) {\r\n      const pattern = state.unsafe[index]\r\n\r\n      // Only look for `atBreak`s.\r\n      // Btw: note that `atBreak` patterns will always start the regex at LF or\r\n      // CR.\r\n      if (!pattern.atBreak) continue\r\n\r\n      const expression = state.compilePattern(pattern)\r\n      /** @type {RegExpExecArray | null} */\r\n      let match\r\n\r\n      while ((match = expression.exec(value))) {\r\n        let position = match.index\r\n\r\n        // Support CRLF (patterns only look for one of the characters).\r\n        if (\r\n          value.codePointAt(position) === 10 /* `\\n` */ &&\r\n          value.codePointAt(position - 1) === 13 /* `\\r` */\r\n        ) {\r\n          position--\r\n        }\r\n\r\n        value = value.slice(0, position) + ' ' + value.slice(match.index + 1)\r\n      }\r\n    }\r\n\r\n    return sequence + value + sequence\r\n  }\r\n\r\n  /**\r\n   * @returns {string}\r\n   */\r\n  function inlineMathPeek() {\r\n    return '$'\r\n  }\r\n}\r\n", "/**\r\n * @import {Construct, State, TokenizeContext, Tokenizer} from 'micromark-util-types'\r\n */\r\n\r\nimport {ok as assert} from 'devlop'\r\nimport {factorySpace} from 'micromark-factory-space'\r\nimport {markdownLineEnding} from 'micromark-util-character'\r\nimport {codes, constants, types} from 'micromark-util-symbol'\r\n\r\n/** @type {Construct} */\r\nexport const mathFlow = {\r\n  tokenize: tokenizeMathFenced,\r\n  concrete: true,\r\n  name: 'mathFlow'\r\n}\r\n\r\n/** @type {Construct} */\r\nconst nonLazyContinuation = {\r\n  tokenize: tokenizeNonLazyContinuation,\r\n  partial: true\r\n}\r\n\r\n/**\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeMathFenced(effects, ok, nok) {\r\n  const self = this\r\n  const tail = self.events[self.events.length - 1]\r\n  const initialSize =\r\n    tail && tail[1].type === types.linePrefix\r\n      ? tail[2].sliceSerialize(tail[1], true).length\r\n      : 0\r\n  let sizeOpen = 0\r\n\r\n  return start\r\n\r\n  /**\r\n   * Start of math.\r\n   *\r\n   * ```markdown\r\n   * > | $$\r\n   *     ^\r\n   *   | \\frac{1}{2}\r\n   *   | $$\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function start(code) {\r\n    assert(code === codes.dollarSign, 'expected `$`')\r\n    effects.enter('mathFlow')\r\n    effects.enter('mathFlowFence')\r\n    effects.enter('mathFlowFenceSequence')\r\n    return sequenceOpen(code)\r\n  }\r\n\r\n  /**\r\n   * In opening fence sequence.\r\n   *\r\n   * ```markdown\r\n   * > | $$\r\n   *      ^\r\n   *   | \\frac{1}{2}\r\n   *   | $$\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function sequenceOpen(code) {\r\n    if (code === codes.dollarSign) {\r\n      effects.consume(code)\r\n      sizeOpen++\r\n      return sequenceOpen\r\n    }\r\n\r\n    if (sizeOpen < 2) {\r\n      return nok(code)\r\n    }\r\n\r\n    effects.exit('mathFlowFenceSequence')\r\n    return factorySpace(effects, metaBefore, types.whitespace)(code)\r\n  }\r\n\r\n  /**\r\n   * In opening fence, before meta.\r\n   *\r\n   * ```markdown\r\n   * > | $$asciimath\r\n   *       ^\r\n   *   | x < y\r\n   *   | $$\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n\r\n  function metaBefore(code) {\r\n    if (code === codes.eof || markdownLineEnding(code)) {\r\n      return metaAfter(code)\r\n    }\r\n\r\n    effects.enter('mathFlowFenceMeta')\r\n    effects.enter(types.chunkString, {contentType: constants.contentTypeString})\r\n    return meta(code)\r\n  }\r\n\r\n  /**\r\n   * In meta.\r\n   *\r\n   * ```markdown\r\n   * > | $$asciimath\r\n   *        ^\r\n   *   | x < y\r\n   *   | $$\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function meta(code) {\r\n    if (code === codes.eof || markdownLineEnding(code)) {\r\n      effects.exit(types.chunkString)\r\n      effects.exit('mathFlowFenceMeta')\r\n      return metaAfter(code)\r\n    }\r\n\r\n    if (code === codes.dollarSign) {\r\n      return nok(code)\r\n    }\r\n\r\n    effects.consume(code)\r\n    return meta\r\n  }\r\n\r\n  /**\r\n   * After meta.\r\n   *\r\n   * ```markdown\r\n   * > | $$\r\n   *       ^\r\n   *   | \\frac{1}{2}\r\n   *   | $$\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function metaAfter(code) {\r\n    // Guaranteed to be eol/eof.\r\n    effects.exit('mathFlowFence')\r\n\r\n    if (self.interrupt) {\r\n      return ok(code)\r\n    }\r\n\r\n    return effects.attempt(\r\n      nonLazyContinuation,\r\n      beforeNonLazyContinuation,\r\n      after\r\n    )(code)\r\n  }\r\n\r\n  /**\r\n   * After eol/eof in math, at a non-lazy closing fence or content.\r\n   *\r\n   * ```markdown\r\n   *   | $$\r\n   * > | \\frac{1}{2}\r\n   *     ^\r\n   * > | $$\r\n   *     ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function beforeNonLazyContinuation(code) {\r\n    return effects.attempt(\r\n      {tokenize: tokenizeClosingFence, partial: true},\r\n      after,\r\n      contentStart\r\n    )(code)\r\n  }\r\n\r\n  /**\r\n   * Before math content, definitely not before a closing fence.\r\n   *\r\n   * ```markdown\r\n   *   | $$\r\n   * > | \\frac{1}{2}\r\n   *     ^\r\n   *   | $$\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function contentStart(code) {\r\n    return (\r\n      initialSize\r\n        ? factorySpace(\r\n            effects,\r\n            beforeContentChunk,\r\n            types.linePrefix,\r\n            initialSize + 1\r\n          )\r\n        : beforeContentChunk\r\n    )(code)\r\n  }\r\n\r\n  /**\r\n   * Before math content, after optional prefix.\r\n   *\r\n   * ```markdown\r\n   *   | $$\r\n   * > | \\frac{1}{2}\r\n   *     ^\r\n   *   | $$\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function beforeContentChunk(code) {\r\n    if (code === codes.eof) {\r\n      return after(code)\r\n    }\r\n\r\n    if (markdownLineEnding(code)) {\r\n      return effects.attempt(\r\n        nonLazyContinuation,\r\n        beforeNonLazyContinuation,\r\n        after\r\n      )(code)\r\n    }\r\n\r\n    effects.enter('mathFlowValue')\r\n    return contentChunk(code)\r\n  }\r\n\r\n  /**\r\n   * In math content.\r\n   *\r\n   * ```markdown\r\n   *   | $$\r\n   * > | \\frac{1}{2}\r\n   *      ^\r\n   *   | $$\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function contentChunk(code) {\r\n    if (code === codes.eof || markdownLineEnding(code)) {\r\n      effects.exit('mathFlowValue')\r\n      return beforeContentChunk(code)\r\n    }\r\n\r\n    effects.consume(code)\r\n    return contentChunk\r\n  }\r\n\r\n  /**\r\n   * After math (ha!).\r\n   *\r\n   * ```markdown\r\n   *   | $$\r\n   *   | \\frac{1}{2}\r\n   * > | $$\r\n   *       ^\r\n   * ```\r\n   *\r\n   * @type {State}\r\n   */\r\n  function after(code) {\r\n    effects.exit('mathFlow')\r\n    return ok(code)\r\n  }\r\n\r\n  /** @type {Tokenizer} */\r\n  function tokenizeClosingFence(effects, ok, nok) {\r\n    let size = 0\r\n\r\n    assert(self.parser.constructs.disable.null, 'expected `disable.null`')\r\n    /**\r\n     * Before closing fence, at optional whitespace.\r\n     *\r\n     * ```markdown\r\n     *   | $$\r\n     *   | \\frac{1}{2}\r\n     * > | $$\r\n     *     ^\r\n     * ```\r\n     */\r\n    return factorySpace(\r\n      effects,\r\n      beforeSequenceClose,\r\n      types.linePrefix,\r\n      self.parser.constructs.disable.null.includes('codeIndented')\r\n        ? undefined\r\n        : constants.tabSize\r\n    )\r\n\r\n    /**\r\n     * In closing fence, after optional whitespace, at sequence.\r\n     *\r\n     * ```markdown\r\n     *   | $$\r\n     *   | \\frac{1}{2}\r\n     * > | $$\r\n     *     ^\r\n     * ```\r\n     *\r\n     * @type {State}\r\n     */\r\n    function beforeSequenceClose(code) {\r\n      effects.enter('mathFlowFence')\r\n      effects.enter('mathFlowFenceSequence')\r\n      return sequenceClose(code)\r\n    }\r\n\r\n    /**\r\n     * In closing fence sequence.\r\n     *\r\n     * ```markdown\r\n     *   | $$\r\n     *   | \\frac{1}{2}\r\n     * > | $$\r\n     *      ^\r\n     * ```\r\n     *\r\n     * @type {State}\r\n     */\r\n    function sequenceClose(code) {\r\n      if (code === codes.dollarSign) {\r\n        size++\r\n        effects.consume(code)\r\n        return sequenceClose\r\n      }\r\n\r\n      if (size < sizeOpen) {\r\n        return nok(code)\r\n      }\r\n\r\n      effects.exit('mathFlowFenceSequence')\r\n      return factorySpace(effects, afterSequenceClose, types.whitespace)(code)\r\n    }\r\n\r\n    /**\r\n     * After closing fence sequence, after optional whitespace.\r\n     *\r\n     * ```markdown\r\n     *   | $$\r\n     *   | \\frac{1}{2}\r\n     * > | $$\r\n     *       ^\r\n     * ```\r\n     *\r\n     * @type {State}\r\n     */\r\n    function afterSequenceClose(code) {\r\n      if (code === codes.eof || markdownLineEnding(code)) {\r\n        effects.exit('mathFlowFence')\r\n        return ok(code)\r\n      }\r\n\r\n      return nok(code)\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @this {TokenizeContext}\r\n * @type {Tokenizer}\r\n */\r\nfunction tokenizeNonLazyContinuation(effects, ok, nok) {\r\n  const self = this\r\n\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    if (code === null) {\r\n      return ok(code)\r\n    }\r\n\r\n    assert(markdownLineEnding(code), 'expected eol')\r\n    effects.enter(types.lineEnding)\r\n    effects.consume(code)\r\n    effects.exit(types.lineEnding)\r\n    return lineStart\r\n  }\r\n\r\n  /** @type {State} */\r\n  function lineStart(code) {\r\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\r\n  }\r\n}\r\n", "/**\r\n * @import {Options} from 'micromark-extension-math'\r\n * @import {Construct, Previous, Resolver, State, Token, TokenizeContext, Tokenizer} from 'micromark-util-types'\r\n */\r\n\r\n// To do: next major: clean spaces in HTML compiler.\r\n// This has to be coordinated together with `mdast-util-math`.\r\n\r\nimport {ok as assert} from 'devlop'\r\nimport {markdownLineEnding} from 'micromark-util-character'\r\nimport {codes, types} from 'micromark-util-symbol'\r\n\r\n/**\r\n * @param {Options | null | undefined} [options={}]\r\n *   Configuration (default: `{}`).\r\n * @returns {Construct}\r\n *   Construct.\r\n */\r\nexport function mathText(options) {\r\n  const options_ = options || {}\r\n  let single = options_.singleDollarTextMath\r\n\r\n  if (single === null || single === undefined) {\r\n    single = true\r\n  }\r\n\r\n  return {\r\n    tokenize: tokenizeMathText,\r\n    resolve: resolveMathText,\r\n    previous,\r\n    name: 'mathText'\r\n  }\r\n\r\n  /**\r\n   * @this {TokenizeContext}\r\n   * @type {Tokenizer}\r\n   */\r\n  function tokenizeMathText(effects, ok, nok) {\r\n    const self = this\r\n    let sizeOpen = 0\r\n    /** @type {number} */\r\n    let size\r\n    /** @type {Token} */\r\n    let token\r\n\r\n    return start\r\n\r\n    /**\r\n     * Start of math (text).\r\n     *\r\n     * ```markdown\r\n     * > | $a$\r\n     *     ^\r\n     * > | \\$a$\r\n     *      ^\r\n     * ```\r\n     *\r\n     * @type {State}\r\n     */\r\n    function start(code) {\r\n      assert(code === codes.dollarSign, 'expected `$`')\r\n      assert(previous.call(self, self.previous), 'expected correct previous')\r\n      effects.enter('mathText')\r\n      effects.enter('mathTextSequence')\r\n      return sequenceOpen(code)\r\n    }\r\n\r\n    /**\r\n     * In opening sequence.\r\n     *\r\n     * ```markdown\r\n     * > | $a$\r\n     *     ^\r\n     * ```\r\n     *\r\n     * @type {State}\r\n     */\r\n\r\n    function sequenceOpen(code) {\r\n      if (code === codes.dollarSign) {\r\n        effects.consume(code)\r\n        sizeOpen++\r\n        return sequenceOpen\r\n      }\r\n\r\n      // Not enough markers in the sequence.\r\n      if (sizeOpen < 2 && !single) {\r\n        return nok(code)\r\n      }\r\n\r\n      effects.exit('mathTextSequence')\r\n      return between(code)\r\n    }\r\n\r\n    /**\r\n     * Between something and something else.\r\n     *\r\n     * ```markdown\r\n     * > | $a$\r\n     *      ^^\r\n     * ```\r\n     *\r\n     * @type {State}\r\n     */\r\n    function between(code) {\r\n      if (code === codes.eof) {\r\n        return nok(code)\r\n      }\r\n\r\n      if (code === codes.dollarSign) {\r\n        token = effects.enter('mathTextSequence')\r\n        size = 0\r\n        return sequenceClose(code)\r\n      }\r\n\r\n      // Tabs don’t work, and virtual spaces don’t make sense.\r\n      if (code === codes.space) {\r\n        effects.enter('space')\r\n        effects.consume(code)\r\n        effects.exit('space')\r\n        return between\r\n      }\r\n\r\n      if (markdownLineEnding(code)) {\r\n        effects.enter(types.lineEnding)\r\n        effects.consume(code)\r\n        effects.exit(types.lineEnding)\r\n        return between\r\n      }\r\n\r\n      // Data.\r\n      effects.enter('mathTextData')\r\n      return data(code)\r\n    }\r\n\r\n    /**\r\n     * In data.\r\n     *\r\n     * ```markdown\r\n     * > | $a$\r\n     *      ^\r\n     * ```\r\n     *\r\n     * @type {State}\r\n     */\r\n    function data(code) {\r\n      if (\r\n        code === codes.eof ||\r\n        code === codes.space ||\r\n        code === codes.dollarSign ||\r\n        markdownLineEnding(code)\r\n      ) {\r\n        effects.exit('mathTextData')\r\n        return between(code)\r\n      }\r\n\r\n      effects.consume(code)\r\n      return data\r\n    }\r\n\r\n    /**\r\n     * In closing sequence.\r\n     *\r\n     * ```markdown\r\n     * > | `a`\r\n     *       ^\r\n     * ```\r\n     *\r\n     * @type {State}\r\n     */\r\n\r\n    function sequenceClose(code) {\r\n      // More.\r\n      if (code === codes.dollarSign) {\r\n        effects.consume(code)\r\n        size++\r\n        return sequenceClose\r\n      }\r\n\r\n      // Done!\r\n      if (size === sizeOpen) {\r\n        effects.exit('mathTextSequence')\r\n        effects.exit('mathText')\r\n        return ok(code)\r\n      }\r\n\r\n      // More or less accents: mark as data.\r\n      token.type = 'mathTextData'\r\n      return data(code)\r\n    }\r\n  }\r\n}\r\n\r\n/** @type {Resolver} */\r\nfunction resolveMathText(events) {\r\n  let tailExitIndex = events.length - 4\r\n  let headEnterIndex = 3\r\n  /** @type {number} */\r\n  let index\r\n  /** @type {number | undefined} */\r\n  let enter\r\n\r\n  // If we start and end with an EOL or a space.\r\n  if (\r\n    (events[headEnterIndex][1].type === types.lineEnding ||\r\n      events[headEnterIndex][1].type === 'space') &&\r\n    (events[tailExitIndex][1].type === types.lineEnding ||\r\n      events[tailExitIndex][1].type === 'space')\r\n  ) {\r\n    index = headEnterIndex\r\n\r\n    // And we have data.\r\n    while (++index < tailExitIndex) {\r\n      if (events[index][1].type === 'mathTextData') {\r\n        // Then we have padding.\r\n        events[tailExitIndex][1].type = 'mathTextPadding'\r\n        events[headEnterIndex][1].type = 'mathTextPadding'\r\n        headEnterIndex += 2\r\n        tailExitIndex -= 2\r\n        break\r\n      }\r\n    }\r\n  }\r\n\r\n  // Merge adjacent spaces and data.\r\n  index = headEnterIndex - 1\r\n  tailExitIndex++\r\n\r\n  while (++index <= tailExitIndex) {\r\n    if (enter === undefined) {\r\n      if (\r\n        index !== tailExitIndex &&\r\n        events[index][1].type !== types.lineEnding\r\n      ) {\r\n        enter = index\r\n      }\r\n    } else if (\r\n      index === tailExitIndex ||\r\n      events[index][1].type === types.lineEnding\r\n    ) {\r\n      events[enter][1].type = 'mathTextData'\r\n\r\n      if (index !== enter + 2) {\r\n        events[enter][1].end = events[index - 1][1].end\r\n        events.splice(enter + 2, index - enter - 2)\r\n        tailExitIndex -= index - enter - 2\r\n        index = enter + 2\r\n      }\r\n\r\n      enter = undefined\r\n    }\r\n  }\r\n\r\n  return events\r\n}\r\n\r\n/**\r\n * @this {TokenizeContext}\r\n * @type {Previous}\r\n */\r\nfunction previous(code) {\r\n  // If there is a previous code, there will always be a tail.\r\n  return (\r\n    code !== codes.dollarSign ||\r\n    this.events[this.events.length - 1][1].type === types.characterEscape\r\n  )\r\n}\r\n", "/**\r\n * @import {Options} from 'micromark-extension-math'\r\n * @import {Extension} from 'micromark-util-types'\r\n */\r\n\r\nimport {codes} from 'micromark-util-symbol'\r\nimport {mathFlow} from './math-flow.js'\r\nimport {mathText} from './math-text.js'\r\n\r\n/**\r\n * Create an extension for `micromark` to enable math syntax.\r\n *\r\n * @param {Options | null | undefined} [options={}]\r\n *   Configuration (default: `{}`).\r\n * @returns {Extension}\r\n *   Extension for `micromark` that can be passed in `extensions`, to\r\n *   enable math syntax.\r\n */\r\nexport function math(options) {\r\n  return {\r\n    flow: {[codes.dollarSign]: mathFlow},\r\n    text: {[codes.dollarSign]: mathText(options)}\r\n  }\r\n}\r\n", "/**\r\n * @import {HtmlOptions as Options} from 'micromark-extension-math'\r\n * @import {HtmlExtension} from 'micromark-util-types'\r\n */\r\n\r\nimport katex from 'katex'\r\n\r\nconst renderToString = katex.renderToString\r\n\r\n/**\r\n * Create an extension for `micromark` to support math when serializing to\r\n * HTML.\r\n *\r\n * > 👉 **Note**: this uses KaTeX to render math.\r\n *\r\n * @param {Options | null | undefined} [options={}]\r\n *   Configuration (default: `{}`).\r\n * @returns {HtmlExtension}\r\n *   Extension for `micromark` that can be passed in `htmlExtensions`, to\r\n *   support math when serializing to HTML.\r\n */\r\nexport function mathHtml(options) {\r\n  return {\r\n    enter: {\r\n      mathFlow() {\r\n        this.lineEndingIfNeeded()\r\n        this.tag('<div class=\"math math-display\">')\r\n      },\r\n      mathFlowFenceMeta() {\r\n        this.buffer()\r\n      },\r\n      mathText() {\r\n        // Double?\r\n        this.tag('<span class=\"math math-inline\">')\r\n        this.buffer()\r\n      }\r\n    },\r\n    exit: {\r\n      mathFlow() {\r\n        const value = this.resume()\r\n        this.tag(math(value.replace(/(?:\\r?\\n|\\r)$/, ''), true))\r\n        this.tag('</div>')\r\n        this.setData('mathFlowOpen')\r\n        this.setData('slurpOneLineEnding')\r\n      },\r\n      mathFlowFence() {\r\n        // After the first fence.\r\n        if (!this.getData('mathFlowOpen')) {\r\n          this.setData('mathFlowOpen', true)\r\n          this.setData('slurpOneLineEnding', true)\r\n          this.buffer()\r\n        }\r\n      },\r\n      mathFlowFenceMeta() {\r\n        this.resume()\r\n      },\r\n      mathFlowValue(token) {\r\n        this.raw(this.sliceSerialize(token))\r\n      },\r\n      mathText() {\r\n        const value = this.resume()\r\n        this.tag(math(value, false))\r\n        this.tag('</span>')\r\n      },\r\n      mathTextData(token) {\r\n        this.raw(this.sliceSerialize(token))\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {string} value\r\n   *   Math text.\r\n   * @param {boolean} displayMode\r\n   *   Whether the math is in display mode.\r\n   * @returns {string}\r\n   *   HTML.\r\n   */\r\n  function math(value, displayMode) {\r\n    return renderToString(value, {...options, displayMode})\r\n  }\r\n}\r\n", "/// <reference types=\"mdast-util-math\" />\r\n/// <reference types=\"remark-parse\" />\r\n/// <reference types=\"remark-stringify\" />\r\n\r\n/**\r\n * @typedef {import('mdast').Root} Root\r\n * @typedef {import('mdast-util-math').ToOptions} Options\r\n * @typedef {import('unified').Processor<Root>} Processor\r\n */\r\n\r\nimport {mathFromMarkdown, mathToMarkdown} from 'mdast-util-math'\r\nimport {math} from 'micromark-extension-math'\r\n\r\n/** @type {Readonly<Options>} */\r\nconst emptyOptions = {}\r\n\r\n/**\r\n * Add support for math.\r\n *\r\n * @param {Readonly<Options> | null | undefined} [options]\r\n *   Configuration (optional).\r\n * @returns {undefined}\r\n *   Nothing.\r\n */\r\nexport default function remarkMath(options) {\r\n  // @ts-expect-error: TS is wrong about `this`.\r\n  // eslint-disable-next-line unicorn/no-this-assignment\r\n  const self = /** @type {Processor} */ (this)\r\n  const settings = options || emptyOptions\r\n  const data = self.data()\r\n\r\n  const micromarkExtensions =\r\n    data.micromarkExtensions || (data.micromarkExtensions = [])\r\n  const fromMarkdownExtensions =\r\n    data.fromMarkdownExtensions || (data.fromMarkdownExtensions = [])\r\n  const toMarkdownExtensions =\r\n    data.toMarkdownExtensions || (data.toMarkdownExtensions = [])\r\n\r\n  micromarkExtensions.push(math(settings))\r\n  fromMarkdownExtensions.push(mathFromMarkdown())\r\n  toMarkdownExtensions.push(mathToMarkdown(settings))\r\n}\r\n"],
  "mappings": "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",
  "names": ["math", "ok", "effects", "nok", "ok"]
}
